# Explorando Apache Camel en profundidad

---

## Realiza llamadas HTTP Rest API desde una ruta Camel

### En el camel-microservice-b

En el `camel-microservice-b` crearé un endpoint que mostrará un objeto hardcodeado. Simplemente, necesitamos tener un
rest controller que exponga un endpoint para realizar pruebas con Camel.

````java

@RestController
@RequestMapping(path = "/api/v1/currencies")
public class CurrencyExchangeController {

    @GetMapping(path = "/currency-exchange/from/{from}/to/{to}")
    public ResponseEntity<CurrencyExchange> findConversionValue(@PathVariable String from, @PathVariable String to) {
        return ResponseEntity.ok(new CurrencyExchange(1003L, from, to, BigDecimal.TEN));
    }

}
````

Si ejecutamos el `camel-microservice-b` y realizamos una petición al endpoint construído, veremos que está funcionando
sin problemas.

````bash
$ curl -v http://localhost:8000/api/v1/currencies/currency-exchange/from/USD/to/PEN | jq
>
< HTTP/1.1 200
< Content-Type: application/json
< Transfer-Encoding: chunked
< Date: Tue, 12 Nov 2024 15:03:12 GMT
<
{
  "id": 1003,
  "from": "USD",
  "to": "PEN",
  "conversionMultiple": 10
}
````

### En el camel-microservice-a

En el `camel-microservice-a` vamos a consumir el endpoint construído en el microservicio anterior utilizando
`Apache Camel`. Para eso, es necesario agregar la siguiente dependencia al `pom.xml` de este microservicio, pues si no
lo hacemos, al momento de ejecutar la aplicación nos mostrará errores.

````xml

<dependency>
    <groupId>org.apache.camel.springboot</groupId>
    <artifactId>camel-http-starter</artifactId>
    <version>4.8.1</version>
</dependency>
````

**Nota**
> Como en este apartado trabajaremos con el consumo de api rest, vamos a comentar la anotación `@Component` de la clase
> `KafkaSenderRoute`.

Ahora, creamos nuestra clase de componente `RestApiConsumerRoute` donde configuramos la ruta de camel para consumir el
endpoint construído anteriormente.

````java

@Component
public class RestApiConsumerRoute extends RouteBuilder {
    @Override
    public void configure() throws Exception {
        restConfiguration()
                .host("localhost")
                .port(8000);

        from("timer:rest-api-consumer?period=10000")
                .setHeader("from", () -> "EUR")
                .setHeader("to", () -> "PEN")
                .log("${body}")
                .to("rest:get:/api/v1/currencies/currency-exchange/from/{from}/to/{to}")
                .log("${body}");
    }
}
````

**Donde**

- `restConfiguration().host("localhost").port(8000)`, configura los parámetros básicos de la conexión `REST`, indicando
  que las peticiones se enviarán a `localhost` en el puerto `8000`. Esta configuración establece el punto base para las
  llamadas `REST` realizadas por esta ruta.


- `from("timer:rest-api-consumer?period=10000")`, la ruta se inicia con un componente `timer`, que dispara eventos cada
  cierto intervalo de tiempo. En este caso, cada `10,000 milisegundos (10 segundos)`. Cada `10 segundos`, `Camel` activa
  esta ruta y ejecuta los pasos definidos.


- `.setHeader("from", () -> "EUR")` y `.setHeader("to", () -> "PEN")`, configura dos encabezados `from` y `to`, con los
  valores `EUR` y `PEN`, respectivamente. Estos headers se usarán luego en el endpoint `REST` como parámetros de ruta.


- El primer `.log("${body}")`, registra el contenido del cuerpo del mensaje en el log de Camel. Al principio, estará
  vacío porque aún no se ha realizado la solicitud al servicio `REST`.


- `.to("rest:get:/api/v1/currencies/currency-exchange/from/{from}/to/{to}")`, envía una solicitud `GET` a la ruta
  `/api/v1/currencies/currency-exchange/from/{from}/to/{to}`. Los parámetros `{from}` y `{to}` se reemplazan
  automáticamente con los valores de los encabezados `from` y `to` (es decir, `EUR` y `PEN`), haciendo que la `URL`
  final sea: `/api/v1/currencies/currency-exchange/from/EUR/to/PEN`. `Apache Camel` toma el cuerpo de la respuesta de
  este servicio y lo establece como el cuerpo del mensaje para los siguientes pasos de la ruta.


- El segundo `.log("${body}")`, vuelve a registrar el cuerpo del mensaje, que ahora contiene la respuesta de la
  `API REST`. Esta respuesta mostrará el resultado de la solicitud al endpoint `REST`.

Esta ruta se ejecuta cada 10 segundos, realiza una solicitud a una API REST configurada en `localhost:8000`, obtiene una
tasa de cambio de divisas entre `EUR` y `PEN`, y registra la respuesta en los logs de la aplicación. Esta estructura
permite consultar servicios `REST` de manera periódica y manejar sus respuestas, integrándose de manera sencilla con
otros componentes de `Camel` y `Spring Boot`.

### Probando el consumo de API REST con Camel

Primero levantamos nuestro `camel-microservices-b`, luego levantamos nuestro `camel-microservice-a` y en consola
veremos el siguiente resultado.

````bash
[camel-microservice-a] [           main] d.m.app.CamelMicroserviceAApplication    : Starting CamelMicroserviceAApplication using Java 21.0.1 with PID 16160 (M:\PERSONAL\PROGRAMACION\DESARROLLO_JAVA_SPRING\01.udemy\04.in28Minutes_Official\apache-camel-projects\camel-microservice-a\target\classes started by USUARIO in M:\PERSONAL\PROGRAMACION\DESARROLLO_JAVA_SPRING\01.udemy\04.in28Minutes_Official\apache-camel-projects)
[camel-microservice-a] [           main] d.m.app.CamelMicroserviceAApplication    : No active profile set, falling back to 1 default profile: "default"
[camel-microservice-a] [           main] o.s.b.w.embedded.tomcat.TomcatWebServer  : Tomcat initialized with port 8080 (http)
[camel-microservice-a] [           main] o.apache.catalina.core.StandardService   : Starting service [Tomcat]
[camel-microservice-a] [           main] o.apache.catalina.core.StandardEngine    : Starting Servlet engine: [Apache Tomcat/10.1.31]
[camel-microservice-a] [           main] o.a.c.c.C.[Tomcat].[localhost].[/]       : Initializing Spring embedded WebApplicationContext
[camel-microservice-a] [           main] w.s.c.ServletWebServerApplicationContext : Root WebApplicationContext: initialization completed in 4210 ms
[camel-microservice-a] [           main] o.s.b.a.e.web.EndpointLinksResolver      : Exposing 1 endpoint beneath base path '/actuator'
[camel-microservice-a] [           main] o.s.b.w.embedded.tomcat.TomcatWebServer  : Tomcat started on port 8080 (http) with context path '/'
[camel-microservice-a] [           main] o.a.c.impl.engine.AbstractCamelContext   : Apache Camel 4.8.1 (camel-1) is starting
[camel-microservice-a] [           main] o.a.c.impl.engine.AbstractCamelContext   : Routes startup (total:1)
[camel-microservice-a] [           main] o.a.c.impl.engine.AbstractCamelContext   :     Started route1 (timer://rest-api-consumer)
[camel-microservice-a] [           main] o.a.c.impl.engine.AbstractCamelContext   : Apache Camel 4.8.1 (camel-1) started in 638ms (build:0ms init:0ms start:638ms)
[camel-microservice-a] [           main] d.m.app.CamelMicroserviceAApplication    : Started CamelMicroserviceAApplication in 10.209 seconds (process running for 11.496)
[camel-microservice-a] [st-api-consumer] route1                                   : null
[camel-microservice-a] [st-api-consumer] route1                                   : {"id":1003,"from":"EUR","to":"PEN","conversionMultiple":10}
[camel-microservice-a] [st-api-consumer] route1                                   : null
[camel-microservice-a] [st-api-consumer] route1                                   : {"id":1003,"from":"EUR","to":"PEN","conversionMultiple":10}
[camel-microservice-a] [st-api-consumer] route1                                   : null
[camel-microservice-a] [st-api-consumer] route1                                   : {"id":1003,"from":"EUR","to":"PEN","conversionMultiple":10}
[camel-microservice-a] [st-api-consumer] route1                                   : null
[camel-microservice-a] [st-api-consumer] route1                                   : {"id":1003,"from":"EUR","to":"PEN","conversionMultiple":10}
````

En el resultado anterior, vemos que el primer `log` de la ruta nos muestra `null` y el segundo `log` el resultado que
retorna el endpoint consumido.
